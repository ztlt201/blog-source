---
title: Gevent 基本概念
date: 2018-06-02 21:23:09
categories: python
tags: gevent
---
# 进程、线程和协程
进程(Process)和线程(Tread)属于操作系统的基本概念，不再累述，它们之间的区别和联系：
* 进程是操作系统资源分配基的最小单位，线程是CPU调度的最小单位。
* 进程不会被CPU直接调度，依赖线程执行任务，线程不拥有系统资源，依赖进程获得运行资源，两者是相互依存的。
* 进程之间不能共享资源，同一个进程的线程之间共享该进程的地址空间和其他资源。
* 进程间通信(IPC)比线程间通信更加困难且消耗更多的资源。

更多讨论，见{% link 进程和线程 https://www.zhihu.com/question/21535820 [external] [title] %}
## What is Coroutine
协程(Coroutines)没有一个标准的官方定义，以下为个人觉得比较好的定义：
{% blockquote %}
Coroutines are computer-program components that generalize subroutines for non-preemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations. Coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.
{% endblockquote %}
{% blockquote %}
协程，即是协作式的例程，它是非抢占式的多任务子例程的概括，可以允许有多个入口点在例程中确定的位置来控制程序的暂停与恢复执行。
{% endblockquote %}
由上述定义，我们可以知道
* 协程是一种编程语言的概念(computer-program components)，而不是操作系统概念，操作系统根本感知不到协程的存在，**它的调度，切换完全是由用户通过编程语言特性控制的。**
* 协程的实现需要向例程提供一种在特定位置挂起和恢复的能力，对于线程，这种能力由操作系统提供，而对于协程，这种能力由编程语言提供，例如Python的yeiled关键字，Lua的coroutine扩展库等。
* 协程并不能完全取代线程，他有特定的使用场景，如协助式多任务、事件循环和迭代器等。

## Why is Coroutine
* **快速切换：**如果说线程的引入是为了轻量化进程，提高分时系统调度引起的上下文切换速度，减少运行时资源开销和管理复杂度，那么协程的引入就是为了轻量化线程.协程的切换只是单纯的CPU的上下文切换，每秒切换上百万次系统都能承受得住。
* **异步编程：**协程是非抢占式的，所以需要开发者自己安排例程控制权的挂起与恢复，同一时间只有一个协程拥有控制权，相当于提供单线程能力，但协程结合非阻塞异步模型，加上其快速切换的能力，能够提供更快更多的任务处理能力
* **减少回调：**异步编程模型中采用的是‘event_loop+callback’的机制，但大量的回调链和嵌套回调会造成共享状态管理困难和异常错误处理困难，而协程拥有自己的栈帧，恢复时上下文自动恢复，在实现上更贴近与同步代码结构。


# Greenlet和Libev
下面讨论gevent使用的底层技术：{% link greenlet http://greenlet.readthedocs.io/en/latest/# %} 和 {% link libev https://github.com/enki/libev %}
## Greenlet
greenlet是一个轻量级并发库，为python提供完整的协程支持，其核心思想是***"Switch not Call"***。
核心函数为:{% codeblock%}
value = g.switch(*args, **kwargs);
{% endcodeblock %}这个函数有两个层面的意思：
* 函数调用：将程序执行权由当前greenlet切换到greenlet ***g***，完成协程间的相互切换。
* 函数返回：由其他greenlet切换回当前greenlet或当前greenlet的某个子greenlet生命周期结束。

{% codeblock%}
from greenlet import greenlet
def func1():
    print "enter func1()"	// print done
    gr2.switch()		// switch to gr2, excute func2
    print "out func2()" 	// never executed	 
    return "return from func1" // never executed

def func2():
    print "enter func2()"	// print done
    # greenlet.getcurrent().parent.switch("switch from func2") // switch to parent greenlet
    print "out funn2()"		// print if line 10 is #
    return "return from func2"	// return value to parent greenlet

gr1 = greenlet(func1)
gr2 = greenlet(func2)
value = gr1.switch()  	//switch to gr1 ,excute func1, and return from line 10 or line 12
print value
{% endcodeblock %}
上面的例子看出，greenlet之间可以通过siwtch()任意切换运行，但多个greenlet之间是串行执行的，且无法保证所有的语句都能执行，例如line 5 和 line 6。因此如何**高效、合理、安全的编排greenlet的执行顺序以完成功能目标**是我们进行greenlet编程的核心工作。

### generator VS greenlet
python提供yield、yield from关键字，使一个函数变成generator。generator是一个半协程(semicoroutines)而greenlet能够提供完整的协程能力。
generator和greenlet都能够使例程在特定位置挂起，中断执行流程并允许重新恢复执行，但是** greenlet能够控制挂起后继续执行的位置，但generator却不能，它只能在把控制权交回给generator的调用者 **。因此generator主要用于简化迭代程序的编写，greenlet作为python协程的一种协程实现方式，广泛的运用在异步编程、状态机等方面。

## Libev
